#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(non_upper_case_globals)]

extern crate link_cplusplus;

mod bindings {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

pub fn validate_proof(
    seed: &[u8; 32],
    k: u8,
    challenge: &[u8; 32],
    proof: &[u8],
    quality: &mut [u8; 32],
) -> bool {
    let Some(proof_len) = proof.len().try_into().ok() else {
        return false;
    };

    unsafe {
        bindings::validate_proof(
            seed.as_ptr(),
            k,
            challenge.as_ptr(),
            proof.as_ptr(),
            proof_len,
            quality.as_mut_ptr(),
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_proofs() {
        /*
         * Generated by printing the inputs to validate_proof in tests/test_python_bindings.py
         * Specifically, the test_k_21 function was adapted to append 100 lines to the file.
         */
        let proofs = include_str!("../test_proofs.txt");

        for line in proofs.lines() {
            let mut parts = line.split(", ");
            let seed = hex::decode(parts.next().unwrap()).unwrap();
            let k = parts.next().unwrap().parse().unwrap();
            let challenge = hex::decode(parts.next().unwrap()).unwrap();
            let proof = hex::decode(parts.next().unwrap()).unwrap();
            let quality = hex::decode(parts.next().unwrap()).unwrap();

            let mut actual_quality = [0; 32];
            assert!(validate_proof(
                &seed.try_into().unwrap(),
                k,
                &challenge.try_into().unwrap(),
                &proof,
                &mut actual_quality
            ));
            assert_eq!(actual_quality.as_slice(), quality);
        }
    }

    #[test]
    fn test_empty_proof() {
        let mut quality = [0; 32];
        assert!(!validate_proof(&[0; 32], 32, &[0; 32], &[], &mut quality));
        assert_eq!(quality, [0; 32]);
    }

    #[test]
    fn test_min_k_size() {
        let mut quality = [0; 32];
        assert!(!validate_proof(&[0; 32], 0, &[0; 32], &[0], &mut quality));
        assert_eq!(quality, [0; 32]);
    }

    #[test]
    fn test_max_k_size() {
        let mut quality = [0; 32];
        assert!(!validate_proof(&[0; 32], 100, &[0; 32], &[0], &mut quality));
        assert_eq!(quality, [0; 32]);
    }

    #[test]
    fn test_wrong_proof_length() {
        let mut quality = [0; 32];
        assert!(!validate_proof(
            &[0; 32],
            32,
            &[0; 32],
            &[0; 1000],
            &mut quality
        ));
        assert_eq!(quality, [0; 32]);
    }

    #[test]
    fn test_bad_proof() {
        let mut quality = [0; 32];
        assert!(!validate_proof(
            &[0; 32],
            32,
            &[0; 32],
            &[0; 32 * 8],
            &mut quality
        ));
        assert_eq!(quality, [0; 32]);
    }
}
